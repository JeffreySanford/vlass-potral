# WebSocket Protocol Specification

## Overview

WebSockets multiplex three topics: `audit`, `ops`, `jobs`. Each message includes correlation ID for tracing.

---

## Message Envelope

```typescript
export interface WsEnvelope<T> {
  tsUtc: string; // ISO 8601 timestamp
  topic: 'audit' | 'ops' | 'jobs';
  type: string; // e.g., "SNAPSHOT_REQUEST", "JOB_PROGRESS"

  // Correlation ID (always present)
  corrId: string; // UUID, generated by sender

  // Optional: links back to client request
  causationId?: string; // If triggered by prior corrId

  payload: T;
}
```

---

## Topics

### Audit Stream (Admins only)

Real-time audit log for admins watching security events.

```typescript
// Client subscribes
ws.send({
  tsUtc: "2026-02-06T20:10:00Z",
  topic: "audit",
  type: "SUBSCRIBE",
  corrId: "c_abc123",
  payload: {},
});

// Server broadcasts to all subscribed admins
{
  tsUtc: "2026-02-06T20:10:01Z",
  topic: "audit",
  type: "AUDIT_EVENT",
  corrId: "s_xyz789",  // Server-generated
  causationId: "http_req_789",  // Caused by HTTP request
  payload: {
    action: "POST_CREATE",
    actor: "user_123",
    status: "SUCCESS",
    latencyMs: 42,
  },
}
```

### Ops Stream (Mods/Admins)

Moderation queue updates.

```typescript
// MOD subscribes to flagged posts
{
  topic: "ops",
  type: "SUBSCRIBE_QUEUE",
  corrId: "c_mod1",
  payload: { queue: "flagged_posts" },
}

// Server notifies when new post is flagged
{
  topic: "ops",
  type: "QUEUE_ITEM",
  corrId: "s_op1",
  causationId: "http_flag_123",
  payload: {
    postId: "p_456",
    flagReason: "SPAM",
    flagCount: 3,
  },
}
```

### Jobs Stream (User-initiated)

Async job progress (snapshot generation, FITS export).

```typescript
// Client requests snapshot
{
  topic: "jobs",
  type: "SNAPSHOT_REQUEST",
  corrId: "c_snap123",
  payload: {
    viewerId: "v_789",
    width: 512,
    height: 512,
  },
}

// Server responds with job ID (immediate)
{
  topic: "jobs",
  type: "JOB_CREATED",
  corrId: "s_job1",
  causationId: "c_snap123",
  payload: { jobId: "job_abc", status: "PENDING" },
}

// Progress updates
{
  topic: "jobs",
  type: "JOB_PROGRESS",
  corrId: "s_job1_p1",
  causationId: "c_snap123",
  payload: { jobId: "job_abc", pct: 25 },
}

{
  topic: "jobs",
  type: "JOB_COMPLETE",
  corrId: "s_job1_done",
  causationId: "c_snap123",
  payload: { jobId: "job_abc", url: "s3://artifacts/..." },
}
```

---

## Implementation

### Server (NestJS)

```typescript
// apps/vlass-api/src/app/ws/ws.gateway.ts

import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';

@WebSocketGateway({ cors: true })
export class WsGateway implements OnGatewayConnection {
  @WebSocketServer() server!: Server;

  constructor(
    private readonly audit: AuditService,
    private readonly corr: CorrelationService,
  ) {}

  handleConnection(client: Socket): void {
    const corrId = this.corr.generateId();
    client.data.corrId = corrId;
    console.log(`[WS] Client connected: ${client.id} (${corrId})`);
  }

  @SubscribeMessage('audit:subscribe')
  async onAuditSubscribe(client: Socket, data: any): Promise<void> {
    const corrId = client.data.corrId;

    // Guard: only ADMIN
    if (!this.auth.hasRole(client.data.userId, 'ADMIN')) {
      client.emit('error', {
        corrId,
        message: 'Unauthorized',
      });
      return;
    }

    client.join('audit');
    client.emit('subscribed', { corrId, topic: 'audit' });
  }

  // Broadcast audit event (called from audit.interceptor)
  broadcastAuditEvent(event: AuditEvent, httpCorrId: string): void {
    const wsCorrId = this.corr.generateId();

    this.server.to('audit').emit('audit:event', {
      tsUtc: new Date().toISOString(),
      topic: 'audit',
      type: 'AUDIT_EVENT',
      corrId: wsCorrId,
      causationId: httpCorrId,
      payload: {
        action: event.action,
        actor: event.actor_id,
        status: event.status,
        latencyMs: event.latency_ms,
      },
    });
  }
}
```

### Client (Angular)

```typescript
// apps/vlass-web/src/app/core/ws/ws.service.ts

import { Injectable } from '@angular/core';
import { io, Socket } from 'socket.io-client';
import { Subject, Observable } from 'rxjs';
import { v4 as uuid } from 'uuid';

@Injectable({ providedIn: 'root' })
export class WsService {
  private socket$ = new Subject<Socket>();
  private audit$ = new Subject<WsEnvelope<any>>();
  private jobs$ = new Subject<WsEnvelope<any>>();

  constructor() {
    this.connect();
  }

  private connect(): void {
    const socket = io('http://localhost:3333', {
      auth: { token: localStorage.getItem('jwt') },
    });

    socket.on('audit:event', (envelope: WsEnvelope<any>) => {
      this.audit$.next(envelope);
    });

    socket.on('job:progress', (envelope: WsEnvelope<any>) => {
      this.jobs$.next(envelope);
    });

    this.socket$.next(socket);
  }

  subscribeToAudit(): Observable<WsEnvelope<any>> {
    const socket = this.socket$.value;
    const corrId = uuid();

    socket.emit('audit:subscribe', {
      tsUtc: new Date().toISOString(),
      topic: 'audit',
      type: 'SUBSCRIBE',
      corrId,
      payload: {},
    });

    return this.audit$;
  }

  requestSnapshot(viewerId: string): Promise<string> {
    const socket = this.socket$.value;
    const corrId = uuid();

    return new Promise((resolve) => {
      socket.emit('jobs:request', {
        tsUtc: new Date().toISOString(),
        topic: 'jobs',
        type: 'SNAPSHOT_REQUEST',
        corrId,
        payload: { viewerId },
      });

      // Wait for JOB_COMPLETE
      this.jobs$
        .pipe(
          filter((e) => e.type === 'JOB_COMPLETE' && e.causationId === corrId),
        )
        .subscribe((e) => {
          resolve(e.payload.url);
        });
    });
  }
}
```

---

## Correlation ID Propagation

```text
HTTP Request (client)
  ↓ Header: X-Correlation-ID: c_abc
  ↓
[NestJS Interceptor]
  Extracts corrId from header
  Stores in request context
  ↓
[Create Post Action]
  POST /community/posts → HTTP 201
  Audit log: causationId = c_abc
  ↓
[Broadcast to WS]
  Emit to "audit" room
  causationId = c_abc (original HTTP corrId)
  ↓
[Admin Sees in UI]
  "Post created (linked to HTTP request c_abc)"
```

---

## Tests

```typescript
// apps/vlass-api-e2e/src/ws-protocol.spec.ts

describe('WebSocket Protocol', () => {
  it('should emit audit event with corrId + causationId', async () => {
    const ws = io('http://localhost:3333');

    const auditPromise = new Promise((resolve) => {
      ws.on('audit:event', (envelope) => {
        resolve(envelope);
      });
    });

    // Trigger HTTP action
    const httpResponse = await request.post('...', {
      headers: { 'X-Correlation-ID': 'http_123' },
    });

    const auditEvent = await auditPromise;

    expect(auditEvent.causationId).toBe('http_123');
    expect(auditEvent.corrId).toBeDefined();
    expect(auditEvent.type).toBe('AUDIT_EVENT');
  });

  it('should only allow ADMIN to subscribe to audit', async () => {
    const userWs = io('http://localhost:3333', {
      auth: { token: userToken },
    });

    const errorPromise = new Promise((resolve) => {
      userWs.on('error', resolve);
    });

    userWs.emit('audit:subscribe', {});

    const error = await errorPromise;
    expect(error.message).toContain('Unauthorized');
  });
});
```

---

**Last Updated:** 2026-02-06

**Key:** Every message has `corrId` (local sender) and optional `causationId` (upstream request).
